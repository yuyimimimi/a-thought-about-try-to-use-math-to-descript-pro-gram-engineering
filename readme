基于图论约束的软件架构设计想法


这是一个软件架构设计的想法。尚未经过全面验证和工程实践，仅供研究和讨论参考。

本文档尝试提出一个，基于图论构建的，通用的关系描述模式。
从而在数学视角上，为软件工程中架构设计这一抽象且主观的工作，提供数学视角上的指导。
这不是一套“解释架构世界的理论”，
而是一套“用形式化方式约束设计空间的规则集”。
它会告诉你一个对象凭什么存在，究竟有什么因果。
它的使用对于架构师或程序员来说是需要一定门槛的,否则无法正确驾驭它。
需要拥有明确的面向对象的架构思想和原子性功能划分的能力
它的表述可能比较晦涩，冗长，因为它只是为了记录而写的初稿。你可以将它交给ai解读，并让ai基于它的约束尝试多写一些代码。处理一些场景。您可以迅速理解它有什么用途。
它假设开发采用文档先行的模式


约束范围界定:

本规约约束的层面（What it governs）
本规约仅约束软件系统的架构结构，具体包括：
1 模块间依赖关系的性质
2 架构拓扑的结构属性
3 抽象层次的组织关系
4.它不关注具体算法实现 

通俗表述:

我们使用c语言编程来举一个例子，让它满足这个规约。首先为了便于分析，我们可以先在编码时对它进行一些约束。 
首先，我们强制面向对象。那么在c语言中，一个对象的定义就是，一个结构体和它的专用操作函数构成的集合。要求，每一个对象对外都是黑盒。  

然后我们来定义强依赖。如果一个对象内部嵌入了另一个对象本身导致其内存布局出现依赖，或者它的成员函数调用了另一个对象的操作函数导致了功能操作存在依赖，那么它就是强依赖。 
如果一个对象只持有了另一个对象的指针，比如只持有句柄。但是它不使用它的操作函数操作它(不使用该对象的操作函数,只负责存储指针)。那么它就是弱依赖。       

在整个架构中，依赖所有的强依赖关系的集合构建出父子关系。比如a强依赖于b，那么b就是a的父亲。 
在以一个对象为参考系的视角中，它的弱依赖对象一定是它的祖先，而强依赖必须是它的子孙。

这里要补充一点，在不同的对象为参考系(比如a强依赖于b,这里b就是参考系)的上下文中，一个非参考系对象要么是强依赖对象，要么是弱依赖对象，要么没有关系(身份是取决于参考系的,而非固定不变的)。  

我们可以通过父子关系构建有向图，所有的对象为节点，将所有强依赖关系为边(比如a强依赖于b，构建b指向a的边)。从而构建一个带有重边的有相图,要求任意两个节点间，所有重边的方向必须一致。
 
此时我们可以以任意一个节点为参考系，通过强弱依赖关系，提取一个子图，获取所有的对象节点(包括参考系节点以及它的所有强依赖和弱依赖节点)，以及这些节点的父子关系的边。
要求:
1.在这个子图中，所有的祖先节点必须相对于参考系节点为弱依赖。而所有子孙节点必须相对于参考系节点为强依赖
2.不得存在孤岛
3.任意一祖先节点到任意子孙节点必须可达



补充:
此外这里还要进行一些补充防止误解，因为许多常见的程序执行并不是直观的面向对象，所以我们要对它进行拓扑:
1.首先，比如依赖注入，获取一个函数指针。那么我们分析时可以对函数指针看作强依赖关系，而持有函数指针的对象看作强依赖一个虚拟的对象。
被作为函数指针注入的对象可以独立分析，它依然是一个或多个节点的集合.
2.对于无明确对象操作的比如malloc，实际上和操作的是一个全局的对象句柄，所以和操作对应的对象完全等价。
3.对于像string sin一类无需传入对象的，可以看作它们拥有一个隐藏的叶子的无额外依赖的对象，调用了他们就是强依赖。
4.一个子可以有多个父
5.一个对象在不同上下文中会有不同身份。


如何使用:
它并不是让你架构设计完成后再去验证。而是要在完全理解它后，基于它去执行架构的设计。

从没有依赖的叶子开始，增量化地构建系统。这或许非常抽象。
但是它会让你逐渐计算出一个健壮的架构。
让架构不是画出来，而是算出来。



常见问题:
1.如果存在两个对象相互依赖，比如是两台服务器相互收发信息，那么要怎么表述?
答:在两个对象间插入一个共有的父节点作为数据交换的节点，它会负责被引用，以满足规约。

2.依赖注入如何处理，如何架构设计

答:依赖注入分析时，先处理持有函数指针的节点，假设它强依赖于一个虚拟的节点用于辅助分析。你可以将它看作一个没有依赖的节点而忽略它，或者引入会注入的依赖的共同依赖，从而执行上下文分析。
在完成这些节点框架的创建后，再去构建被注入的依赖。
你在构建依赖时，你会发现你依然还是遵守一样的原则进行分析。


3.对于中断路由之类如何处理
很明显还是和依赖注入是完全一致的

4.对于操作全局寄存器怎么处理
寄存器这类共享资源本身就是一个节点

5.它是否会影响性能
在本人的测试中大部分情况下它并不会带来严重的性能影响。
它会需要你去写更多代码，但是大部分情况下，编译器会为你优化它。
但是它不是万能的，它不代表一定性能最优。

5.总结:
如果遇到认为难以解释的架构，就说明它可能并不是很合适，
您需要转变思维方式，找到符合约束的功能相同的架构。这会很抽象，但是这也是它的难点。





免责声明

未经工业级的生产实践验证，请勿将此规约直接用于实际项目开发。

作者对使用此想法可能造成的任何损失或问题不承担责任。

欢迎讨论完善：此想法开放讨论，欢迎提出改进意见，但请注意这只是一个构思。

