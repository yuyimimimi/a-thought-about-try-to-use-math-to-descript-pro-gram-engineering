基于图论约束的软件架构设计想法


这是一个软件架构设计的想法。尚未经过全面验证和工程实践，仅供研究和讨论参考。

本文在尝试寻找一个软件架构的表达模式。他不一定通用，因为软件的需求多种多样，他不可能涵盖所有需求。但是一定能够描述一些架构。

在软件工程中我们往往强调可读性，可维护性，可拓展性，高内聚，低耦合....。但是它们都是主观的，它代表了工程师们的主观思想。但是没有人能够将它量化，没有人能够清晰地说明它们究竟是什么。
本人认为它们的本质，就是去约束软件的架构设计，让它们可以更容易被人无歧义地理解。

所以我认为软件工程的各项指标并不是说要让你学习代码应该怎么做，而是怎么样能够被人类理解。

所以我认为我们现需要采用数学模型来无歧义地描述它。当然，因为软件有无限可能，数学模型也必然无法包含它的一切。我认为或许未来描述一个软件的架构，或许需要多种不同的数学模型。

所有长期成功的软件架构，都是“可以被无歧义描述的”，而使用它推理出的架构也同时能够被它使用数学无歧义地表达出来。

本文档尝试提出一个，基于图论构建的架构的描述模式，他不一定能描述所有架构，但是能够帮助你基于数学而不是经验，无歧义且思维一致地，推理出一个架构，并且让推理出的这个架构能够被它本身无歧义地建模。

它就和软件工程里的指标一样，你的代码不一定需要它。但是它可以作为在架构建模上的一个初步探索。

它的使用对于架构师或程序员来说是需要一定门槛的,否则无法正确驾驭它。
需要拥有明确的面向对象的架构思想和原子性功能划分的能力
它的表述可能比较晦涩，冗长，因为它只是为了记录而写的初稿。你可以将它交给ai解读，并让ai基于它的约束尝试多写一些代码。处理一些场景。您可以迅速理解它有什么用途。
它假设开发采用文档先行的模式


约束范围界定:

本规约约束的层面（What it governs）
本规约仅约束软件系统的架构结构，具体包括：
1 模块间依赖关系的性质
2 架构拓扑的结构属性
3 抽象层次的组织关系
4.它不关注具体算法实现 

通俗表述:

我们使用c语言编程来举一个例子，让它满足这个规约。首先为了便于分析，我们可以先在编码时对它进行一些约束。 
首先，我们强制面向对象。那么在c语言中，一个对象的定义就是，一个结构体和它的专用操作函数构成的集合。要求，每一个对象对外都是黑盒。  

然后我们来定义强依赖。如果一个对象内部嵌入了另一个对象本身导致其内存布局出现依赖，或者它的成员函数调用了另一个对象的操作函数导致了功能操作存在依赖，那么它就是强依赖。 
如果一个对象只持有了另一个对象的指针，比如只持有句柄。但是它不使用它的操作函数操作它(不使用该对象的操作函数,只负责存储指针)。那么它就是弱依赖。       

在整个架构中，依赖所有的强依赖关系的集合构建出父子关系。比如a强依赖于b，那么b就是a的父亲。 
在以一个对象为参考系的视角中，它的弱依赖对象一定是它的祖先，而强依赖必须是它的子孙。

这里要补充一点，在不同的对象为参考系(比如a强依赖于b,这里b就是参考系)的上下文中，一个非参考系对象要么是强依赖对象，要么是弱依赖对象，要么没有关系(身份是取决于参考系的,而非固定不变的)。  

我们可以通过父子关系构建有向图，所有的对象为节点，将所有强依赖关系为边(比如a强依赖于b，构建b指向a的边)。从而构建一个带有重边的有相图,要求任意两个节点间，所有重边的方向必须一致。
 
此时我们可以以任意一个节点为参考系，通过强弱依赖关系，提取一个子图，获取所有的对象节点(包括参考系节点以及它的所有强依赖和弱依赖节点)，以及这些节点的父子关系的边。
要求:
1.在这个子图中，所有的祖先节点必须相对于参考系节点为弱依赖。而所有子孙节点必须相对于参考系节点为强依赖
2.不得存在孤岛
3.任意一祖先节点到任意子孙节点必须可达



补充:
此外这里还要进行一些补充防止误解，因为许多常见的程序执行并不是直观的面向对象，所以我们要对它进行拓扑:
1.首先，比如依赖注入，获取一个函数指针。那么我们分析时可以对函数指针看作强依赖关系，而持有函数指针的对象看作强依赖一个虚拟的对象。
被作为函数指针注入的对象可以独立分析，它依然是一个或多个节点的集合.
2.对于无明确对象操作的比如malloc，实际上和操作的是一个全局的对象句柄，所以和操作对应的对象完全等价。
3.对于像string sin一类无需传入对象的，可以看作它们拥有一个隐藏的叶子的无额外依赖的对象，调用了他们就是强依赖。
4.一个子可以有多个父
5.一个对象在不同上下文中会有不同身份。


如何使用:
它并不是让你架构设计完成后再去验证。而是要在完全理解它后，基于它去执行架构的设计。

从没有依赖的叶子开始，增量化地构建系统。这或许非常抽象。
但是它会让你逐渐计算出一个健壮的架构。
让架构不是画出来，而是算出来。



常见问题:
1.如果存在两个对象相互依赖，比如是两台服务器相互收发信息，那么要怎么表述?
答:在两个对象间插入一个共有的父节点作为数据交换的节点，它会负责被引用，以满足规约。

2.依赖注入如何处理，如何架构设计

答:依赖注入分析时，先处理持有函数指针的节点，假设它强依赖于一个虚拟的节点用于辅助分析。你可以将它看作一个没有依赖的节点而忽略它，或者引入会注入的依赖的共同依赖，从而执行上下文分析。
在完成这些节点框架的创建后，再去构建被注入的依赖。
你在构建依赖时，你会发现你依然还是遵守一样的原则进行分析。


3.对于中断路由之类如何处理
很明显还是和依赖注入是完全一致的

4.对于操作全局寄存器怎么处理
寄存器这类共享资源本身就是一个节点

5.它是否会影响性能
在本人的测试中大部分情况下它并不会带来严重的性能影响。
它会需要你去写更多代码，但是大部分情况下，编译器会为你优化它。
但是它不是万能的，它不代表一定性能最优。

5.总结:
如果遇到认为难以解释的架构，就说明它可能并不是很合适，
您需要转变思维方式，找到符合约束的功能相同的架构。这会很抽象，但是这也是它的难点。
